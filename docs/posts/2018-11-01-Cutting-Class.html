<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>A Category of Systems - Cutting Class</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
    </head>
    <body>
        <table class="header">
  <tr>
    <td colspan="2" rowspan="2" class="width-auto">
      <a href="../">
      <img src="../images/mono.svg" height="32pt">
      <h1 class="title">A Category of Systems</h1>
      </a>
      <span class="subtitle">Exploring the consequences of Systems & Cybernetics in Engineering</span>
    </td>
    <th><button onclick="toggleDarkMode()"> Dark  </button> </th>
    <td class="width-min">
    <button><a href="../bits/antipatterns.html">Patterns</a></button>
    </td>
  </tr>
  <tr>
    <th><a href="../atom.xml"><button>Atom </button> </a> </th>
    <td class="width-min"><button><a href="../archive.html">Archive</a></button></td>
  </tr>
  <tr>
    <th class="width-min">Author</th>
    <td class="width-auto"><a href="../bits/about.html">Tom Westbury</a></td>
    <th class="width-min">License</th>
    <td><a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img class="inline" alt="Creative Commons Licence" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a></td>
  </tr>
</table>
        <div id="content">

            <table>
    <tr>
    <th rowspan="2">
<h1 class="tabulatedh">Cutting Class</h1>
    </th>
    <td class="width-min" rowspan="2">
     
    </td>
    <th>
        Date
    </th>
    <td>
        2019-02-11
    </td>
    <tr>
    <th>
        Tags
    </th>
    <td>
    </td>
    </tr>
    </tr>
</table>

<p>Classes (or <em>Blocks</em> as they are known in SysML) are a use­ful and al­most un­avoid­able con­cept in UML. They are the mod­el­ling con­cept that al­lows for ob­jec­t-ori­ented in­her­i­tance in the lan­guage and its di­alects. In fact it is im­pos­si­ble to utilise in­her­i­tance as a pat­tern for reuse with­out it. How­ev­er, classes are not as cru­cial to ob­ject ori­ented de­sign as you may think. In this post I will make the case for a dif­fer­ent form of ob­ject ori­en­ta­tion which does away with classes al­to­geth­er.
<!--more-->
In the ob­jec­t-ori­ented pro­gram­ming par­a­digm, there are two main pat­terns for in­her­i­tance: clas­si­cal and pro­to­typ­al. Clas­si­cal in­her­i­tance re­quires no in­tro­duc­tion. For those who don’t know it, Pro­to­typal in­her­i­tance is a very dif­fer­ent beast.</p>
<p>There are no classes in pro­to­typal in­her­i­tance sys­tems, <em>ob­jects just link to other ob­jects</em>. Any ob­ject can in­herit from an­oth­er. This means that any ob­ject can be used as a tem­plate for an­other with­out the need for a class. If you are en­trenched in a clas­si­cal mind­set, it may help to imag­ine that each ob­ject has a “hid­den” class be­hind it that can change as its ob­ject is mod­i­fied.</p>
<p>One of the el­e­gant things about pro­to­typal in­her­i­tance is that it can be used to recre­ate clas­si­cal in­her­i­tance. By defin­ing an ob­ject as con­stant, you ef­fec­tively cre­ate a class. Though these ob­jects can still be used as in­puts to op­er­a­tions. A set of these con­stant ob­jects could be used to cre­ate any in­her­i­tance trees that you like. There­fore clas­si­cal in­her­i­tance can be thought of as a pat­tern within the more ab­stract pro­to­typal sys­tem.</p>
<p>At­tempt­ing to model pro­to­typal in­her­i­tance in a clas­si­cal way is a far messier en­deav­our. This means that the se­man­tics of UML are not suit­able for mod­el­ling many of the con­structs in pro­to­typal lan­guages such as JavaScript. Hav­ing to con­strain your so­lu­tion lan­guage to fit your mod­el­ling lan­guage is a huge no no for ab­strac­tion yet UML mod­ellers seem to tol­er­ate this fail­ing. Note that pro­to­typal in­her­i­tance is not the only hard to ex­press con­cept in UML, oth­ers are first class func­tions and gener­ics, but those are top­ics for ex­plo­ration in fu­ture ar­ti­cles. To un­der­stand why clas­si­cal in­her­i­tance is such an in­te­gral part of UML we shall look back at the pro­gram­ming lan­guages that shaped UM­l’s de­vel­op­ment.</p>
<h2 id="class-struggle">Class strug­gle</h2>
<blockquote>
<p><em>The his­tory of all hith­erto ex­ist­ing ob­jec­t-ori­ented de­sign is the his­tory of class strug­gle</em>
Karl Marx (para­phrased)</p>
</blockquote>
<p>So how come classes be­came such an in­te­gral part of in­her­i­tance in pro­gram­ming? The an­swer is com­piler op­ti­mi­sa­tion. Hav­ing a class gives the ma­chine a tem­plate telling it ex­actly how much mem­ory to al­lo­cate each time it makes a new ob­ject. This is why the class pat­tern came to promi­nence in C where there were no com­piler op­ti­mi­sa­tions for ob­ject ori­en­ta­tion. The C++ lan­guage, which orig­i­nally tran­spiled to C, in­her­ited this way of do­ing things.</p>
<p>In the es­say <a href="http://web.cecs.pdx.edu/~black/publications/ClassesHarmful.pdf">Classes Con­sid­ered Harm­ful</a> The au­thor sug­gests that “class” is a pre­ma­ture op­ti­mi­sa­tion in the code that should be avoid­ed. In the case of mod­el­ling lan­guages though, com­piler op­ti­mi­sa­tion ar­gu­ments don’t re­ally cut it as a jus­ti­fi­ca­tion. <em>Mod­el­ling lan­guages are of course ul­ti­mately hu­man, not ma­chine, con­sum­able.</em> To be fair to the three ami­goes in the early UML days, clas­si­cal in­her­i­tance is a sen­si­ble choice wnen your lan­guage is be­ing used mainly to model things that will be im­ple­mented in ei­ther Java or C++.</p>
<p>From ex­pe­ri­ence, one of the hard­est no­tions to teach new sys­tems mod­ellers is the class/ob­ject dis­tinc­tion. Most soft­ware en­gi­neers are com­fort­able with, some­times mil­i­tantly stuck with, think­ing in the class/ob­ject way. How­ever most new sys­tems en­gi­neers are drawn from en­gi­neer­ing, physics and maths back­grouds of­ten with their only con­tact with code be­ing through C, Mat­lab or For­tran. These peo­ple of­ten find the class/ob­ject dis­tinc­tion hard to get their head around (I was def­i­nitely in this cat­e­gory to be­gin with).</p>
<p>An ex­am­ple of this would be not un­der­stand­ing why two SysML Blocks (Class­es) could not have their ports con­nected to­gether on an in­ter­nal block di­a­gram (struc­ture di­a­gram). It is not im­me­di­ately ob­vi­ous why we must in­stan­ti­ate classes as ob­jects be­fore us­ing them and al­though ob­ject ori­ented folk take this fact for grant­ed, pro­to­typal in­her­i­tance forces us to reeval­u­ate this “fac­t”. The class is al­most a <a href="https://en.wikipedia.org/wiki/Platonic_realism"><em>pla­tonic ideal</em></a> of the ob­jects that in­stan­ti­ate it. So what would a mod­el­ling lan­guage with­out classes change about the way we work?</p>
<p>The first ma­jor im­prove­ment to our work­flow that pro­to­typal in­her­i­tance pro­vides is a re­duc­tion in com­plex­ity to class heirar­chies in mod­els. We tend to think of class heirar­chies in terms of only the classes and for­get that each ob­ject on the end of it is also part of this hi­er­ar­chy. For mod­els with large num­bers of sin­gle use class­es, pro­to­typal in­her­i­tance would be a nat­ural choice as far fewer model el­e­ments would be re­quired.</p>
<p>UML ag­gre­ga­tion also makes more sense un­der a pro­to­typal sys­tem. Ag­gre­ga­tion is a rarer weaker form of the com­po­si­tion as­so­ci­a­tion in UML. Com­po­si­tion is well un­der­stood as if a class is com­posed of an­oth­er, it means that the first class con­tains a prop­erty typed by the sec­ond. Ag­gre­ga­tion, how­ev­er, is more con­fus­ing. an ag­gre­ga­tion as­so­ci­a­tion from one class to an­other tells us that the first class uses an ob­ject typed by the sec­ond. The most we know is that the ag­gre­gat­ing class has a “point­er” typed by the ag­gre­gate class; we re­quire more in­for­ma­tion in the in­stance model to know what’s re­ally go­ing on. In a pro­to­typal mod­el, the class model is the in­stance model and there­fore we know ex­actly which ob­ject each ob­ject is linked to.</p>
<p>Pro­to­typal in­her­i­tance has bonuses over clas­si­cal in­her­i­tance from a tool per­spec­tive too. Pro­to­typal in­her­i­tance is of­ten im­ple­mented us­ing del­e­ga­tion. This means that each ob­ject only records its de­vi­a­tion from its par­ent ob­ject. When ac­cess­ing a prop­erty called ‘fred’ of a pro­to­typal ob­ject, the sys­tem will fol­low the in­her­i­tance pro­to­type chain un­til it finds ‘fred’. This is very sim­i­lar to the <a href="https://sourcemaking.com/design_patterns/flyweight">‘Fly­weight’ GoF pat­tern</a> which lends it­self to ef­fi­cient use of mem­ory when build­ing large data­bases of ob­jects.</p>
<p>To con­clude I’ll leave you with a para­phrased story from clas­si­cal Greece. Plato was once giv­ing a lec­ture on his ideas of re­al­i­ty. He told the au­di­ence how all ob­jects in re­al­ity are mere in­stan­ti­a­tions of di­vine class­es. At that in­stant the trou­ble maker Dio­genes walked in and pointed at a cup that Plato was hold­ing. “If that’s only an in­stance of the class Cup” he in­ter­ject­ed, “Where is this di­vine class Cup?”. Pla­to, coolly replied: “Of course, the class Cup is in the uni­ver­sal source code, not ac­cess­able to us mere mor­tal­s”. Dio­genes, un­de­terred, walked up onto Pla­to’s plat­form and de­clared: “Y­our cup is emp­ty, Pla­to. Please do tell us all here where this con­cept of emp­ty­ness is”. Plato calmly con­tem­plated this for a few sec­onds and said “The lack of a con­tents to my cup is an in­stance of the null ob­ject class in the di­vine source code”. “That’s where you’re wrong” replied Dio­genes. “The true emp­ty­ness is here” he said as he tapped Pla­to’s head.</p>
<p>This post was in­spired by the in­her­i­tance sys­tem in JavaScript. If you want to know more,this site is a good place to start: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">In­her­i­tance and the pro­to­type chain</a>.</p>

<div id="disqus_thread"></div>
<script>
    /**
    *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
    *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables    */
    /*
    var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    */
    (function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = 'https://https-cathxrsis-github-io.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a> | 
            Theme based on <a href="https://wickstrom.tech"><cite>Oskar
Wickström's</cite></a> <a href="https://owickstrom.github.io/the-monospace-web/">Monospace Web.</a>
        </div>
    </body>
    <script>
        function toggleDarkMode(){
            var element = document.body;
            element.classList.toggle("light-mode");
        }
    </script>
</html>
